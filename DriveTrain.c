#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     frontLeft,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     frontRight,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     backRight,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     backLeft,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     intake,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     linearSlide,   tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"

int x1 = joystick.joy1_x1;
int x2 = joystick.joy1_x2;
int y1 = joystick.joy1_y1;
bool precisionMode = false;
int deadzone = 8;
int speedFactor = 1;
int precisionDeadZone = 16;

int x = 1; int a = 2; int b = 3; int y = 4; /* Buttons */
int leftBumper = 5; int rightBumper = 6; /* bumpers */
int leftTrigger = 7; int rightTrigger = 8; /* triggers */

task main()
{
	waitForStart();

	while(true)
	{

		/*	Update jostick settings		*/
		getJoystickSettings(joystick);

		/*	Variables for joystick values	*/
		x1 = joystick.joy1_x1;
		y1 = joystick.joy1_y1;
		x2 = joystick.joy1_x2;

		/*	Toggles precision controlling	*/
		if (joy1Btn(leftTrigger))
		{
			precisionMode == false ? true : false;
		}

		/*	Toggles half/full speed		*/
		if (joy1Btn(rightTrigger))
		{
			speedFactor == 2 ? 1 : 2;
		}

		/*	Filter minute	*/
		if (abs(x1) < deadzone)
		{
			x1 = 0;
		}

		if (abs(y1) < deadzone)
		{
			y1 = 0;
		}

		if (precisionMode)
		{
			// Somehow do driving

			if (abs(x1) > precisionDeadZone && abs(y1) > precisionDeadZone)
			{
				x1 = x1 / abs(x1) * ((y1 + x1)/2);
			}
			else if (abs(x1) > precisionDeadZone && abs(y1) < precisionDeadZone)
			{
				y1 = 0;
			}
			else if (abs(x1) < precisionDeadZone && abs(y1) > precisionDeadZone)
			{
				x1 = 0;
			}
			else
			{
				x1 = 0;
				y1 = 0;
			}
		}

		motor[frontLeft] = y1 + x1 + x2;
		motor[frontRight] = -y1 + x1 + x2;
		motor[backLeft] = y1 - x1 + x2;
		motor[backRight] = -y1 - x1 + x2;


	}
}
